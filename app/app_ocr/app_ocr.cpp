#include "app_ocr.hpp"

DEFINE_string(pt_dbnet, "models/dbnet_pytorch/dbnet_traced.pt", "The pt file used to find net configuration");
DEFINE_string(config_file_dbnet, "app/app_ocr/build_config_dbnet.json", "The JSON config file for parsing model");
DEFINE_string(cali_config_dbnet, "app/app_ocr/cali_config_dbnet.json", "The JSON config file for parsing model");
DEFINE_string(output_model_dbnet, "models/dbnet_pytorch//dbnet_model", "The output model generated by magicmind");
DEFINE_string(cali_filelist_dbnet, "data/images/quant_dbnet/file_list", "The calibration file list");

DEFINE_string(pt_crnn, "models/crnn_pytorch/crnn_traced.pt", "The pt file used to find net configuration");
DEFINE_string(config_file_crnn, "app/app_ocr/build_config_crnn.json", "The JSON config file for parsing model");
DEFINE_string(cali_config_crnn, "app/app_ocr/cali_config_crnn.json", "The JSON config file for parsing model");
DEFINE_string(output_model_crnn, "models/crnn_pytorch/crnn_model_firstconv", "The output model generated by magicmind");
DEFINE_string(cali_filelist_crnn, "data/images/quant_crnn/file_list", "The calibration file list");

DEFINE_int32(threads, 1, "data_parallel*threads*model_parallel should <= 32");


int test_decode_cncv_ocr(int argc, char* argv[]){
    ::google::InitGoogleLogging(argv[0]);
    FLAGS_alsologtostderr = 1;
    namespace gflags = google;
    gflags::ParseCommandLineFlags(&argc, &argv, true);
    vector<cnPipe *> pipes;
    int num = FLAGS_threads;    
    int dst_w_dbnet = 896;
    int dst_h_dbnet = 736;
    int dst_w_crnn = 100;
    int dst_h_crnn = 32;
    
    for(int i=0; i<num; i++){    
        auto src = new CncodecImageProvider(i, "data/images/test_ocr/file_list", true, true);
        auto idgen = new IdGenerator();        
        auto pre_dbnet = new PreDbnetProcesser(i, dst_w_dbnet, dst_h_dbnet);        
        auto *infer_dbnet = new Inferencer(mPytorch, 
                                           FLAGS_cali_filelist_dbnet, 
                                           FLAGS_cali_config_dbnet,
                                           FLAGS_config_file_dbnet, 
                                           FLAGS_pt_dbnet, 
                                           "1,3,736,896", 
                                           "dbnet", 
                                           FLAGS_output_model_dbnet,
                                           false,
                                           0, 0);
        auto copyout_dbnet = new InferMemCopyoutOperator(i);
        auto post_dbnet = new PostDbnetProcesser();
        auto pre_crnn = new PreCrnnProcesser(i, dst_w_crnn, dst_h_crnn);
        auto *infer_crnn  = new InferencerMultiDataParallel(1,
                                                          mPytorch, 
                                                          FLAGS_cali_filelist_crnn, 
                                                          FLAGS_cali_config_crnn,
                                                          FLAGS_config_file_crnn, 
                                                          FLAGS_pt_crnn, 
                                                          "1,1,32,100",
                                                          "crnn", 
                                                          FLAGS_output_model_crnn,
                                                          false,
                                                          1, 0);
        auto copyout_crnn = new InferMultiMemCopyoutOperator(i, 1);
        auto post_crnn = new PostCrnnProcesser();
        cnPipe *pipe = new cnPipe(i, true, true);
        pipe->add(src);
        pipe->add(idgen);

        pipe->add(pre_dbnet);
        pipe->add(infer_dbnet);
        pipe->add(copyout_dbnet);
        pipe->add(post_dbnet);

        pipe->add(pre_crnn);
        pipe->add(infer_crnn);        
        pipe->add(copyout_crnn);
        pipe->add(post_crnn);
        pipes.push_back(pipe);
    }

    for(int i=0; i<num; i++){
        pipes[i]->init();
    }

    Timer t;
    for(int i=0; i<num; i++){
        pipes[i]->start();
    }

    for(int i=0; i<num; i++){
        pipes[i]->sync();
    }
    t.duration("test_decode_cncv_ocr exec:");

    return 0;
}


/* ============================================================ */
int main(int argc, char* argv[])
{    
    test_decode_cncv_ocr(argc, argv);
}

